use std::fmt::{Display, Formatter};
use std::io::Cursor;

/// Represents a library version.
///
/// A version can either be unknown (i.e. not yet supported) or be part of a broader
/// _range of versions_ that groups compatible library versions from a specific macOS release.
pub enum Version {
    Unknown(u64),
    Range(VersionRange),
}

impl Display for Version {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Version::Unknown(number) => write!(f, "Unknown ({number})"),
            Version::Range(r) => r.fmt(f),
        }
    }
}

/// A range of version numbers of the Photos library database.
///
/// The macOS Photos library database has a version number that changes with each update.
/// Each Photos version has a range of version numbers that it uses that are (mostly) compatible
/// with each other. This struct represents such a range.
///
/// All known version ranges are defined as constants on this struct which are generated by the
/// `version_ranges!` macro.
#[derive(PartialEq, PartialOrd)]
pub struct VersionRange {
    pub start: u64,
    pub end: u64,
    pub description: &'static str,
}

impl Display for VersionRange {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{} (versions {} to {})",
            self.description, self.start, self.end
        )
    }
}

/// Generates the known version ranges as constants on the `VersionRange` struct.
///
/// A `from_version_number` method is also generated that returns the version range for a given
/// version number.
macro_rules! version_ranges {
    ($($name:ident($start:literal, $end:literal, $desc:literal)),+) => {
        impl VersionRange {
            $(
            pub const $name:Self = Self { start: $start, end: $end, description: $desc };
            )*

            pub fn from_version_number(version: u64) -> Option<Self> {
                match version {
                    $($start ..= $end => Some(Self::$name),)*
                    _ => None
                }
            }
         }
    };
}

version_ranges! {
    PRE_SONOMA(0, 16999, "Older than macOS Sonoma"),
    SONOMA(17000, 17599, "Photos 9.0, macOS 14.0 to 14.5 Sonoma"),
    SONOMA_14_6(17600, 17999, "Photos 9.0, macOS 14.6 Sonoma"),
    SEQUOIA(18000, 18999, "Photos 10.0, macOS 15 Sequoia"),
    TAHOE(19000, 19500, "Photos 11.0, macOS 26 Tahoe")
}

const MIN_SUPPORTED_VERSION: VersionRange = VersionRange::SEQUOIA;

/// Gets the binary encoded version plist from the Photos library database.
///
/// The version plist is stored in the `Z_METADATA` table of the Photos library database and, once
/// decoded, contains the version number of the database.
fn get_binary_version_plist(connection: &rusqlite::Connection) -> rusqlite::Result<Vec<u8>> {
    let mut stmt = connection.prepare("SELECT Z_PLIST from Z_METADATA ORDER BY Z_VERSION DESC")?;

    stmt.query_row([], |row| row.get::<usize, Vec<u8>>(0))
}

/// Gets the raw version number of the Photos library database.
fn get_version_number(connection: &rusqlite::Connection) -> crate::Result<u64> {
    let binary_version_plist = get_binary_version_plist(connection).map_err(|e| {
        format!(
            "Unable to get version plist from database: {}",
            e.to_string()
        )
    })?;

    let cursor = Cursor::new(binary_version_plist);

    let version = plist::Value::from_reader(cursor)
        .map_err(|e| format!("Unable to parse binary version plist: {}", e.to_string()))?
        .as_dictionary()
        .and_then(|dict| dict.get("PLModelVersion"))
        .and_then(|version| version.as_unsigned_integer())
        .ok_or("Unable to read model version from plist")?;

    Ok(version)
}

/// Returns the version of the library.
pub fn get_version(connection: &rusqlite::Connection) -> crate::Result<Version> {
    let version_number = get_version_number(connection)?;

    let version = VersionRange::from_version_number(version_number)
        .map(|range| Version::Range(range))
        .unwrap_or(Version::Unknown(version_number));

    Ok(version)
}

/// Performs a version check on the database and logs a warning if the respective library version is
/// not supported.
pub fn perform_version_check(db_conn: &rusqlite::Connection) -> crate::Result<()> {
    let version = get_version(&db_conn)?;

    match version {
        Version::Unknown(number) => {
            println!("The provided library has an unknown version ({}) and might not work with this program!", number);
            crate::confirmation::wait_for_enter_key_press();
        }
        Version::Range(range) if range < MIN_SUPPORTED_VERSION => {
            println!("The provided library has an old version that is not officially supported by this program!");
            println!("The minimum required version is {}", MIN_SUPPORTED_VERSION);
            crate::confirmation::wait_for_enter_key_press();
        }
        _ => {}
    }

    Ok(())
}
